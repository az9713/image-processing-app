// SVG processing utilities for image processing app
(function(global) {
    'use strict';
    
    var SVGProcessor = {
        // Parse SVG and extract dimensions
        parseSVG: function(svgString) {
            var parser = new DOMParser();
            var svgDoc = parser.parseFromString(svgString, 'image/svg+xml');
            var svgElement = svgDoc.documentElement;
            
            if (svgElement.nodeName === 'parsererror') {
                throw new Error('Invalid SVG content');
            }
            
            var width = svgElement.getAttribute('width');
            var height = svgElement.getAttribute('height');
            var viewBox = svgElement.getAttribute('viewBox');
            
            // Extract dimensions from viewBox if width/height not specified
            if (!width || !height) {
                if (viewBox) {
                    var viewBoxValues = viewBox.split(/\s+|,/);
                    if (viewBoxValues.length >= 4) {
                        width = width || viewBoxValues[2];
                        height = height || viewBoxValues[3];
                    }
                }
            }
            
            // Default dimensions if not found
            width = parseFloat(width) || 300;
            height = parseFloat(height) || 150;
            
            return {
                element: svgElement,
                width: width,
                height: height,
                viewBox: viewBox,
                content: svgString
            };
        },
        
        // Convert SVG to canvas
        renderToCanvas: function(svgString, maxWidth, maxHeight) {
            return new Promise(function(resolve, reject) {
                try {
                    var svgInfo = SVGProcessor.parseSVG(svgString);
                    
                    // Calculate scale to fit within max dimensions
                    var scale = 1;
                    if (maxWidth && maxHeight) {
                        var scaleX = maxWidth / svgInfo.width;
                        var scaleY = maxHeight / svgInfo.height;
                        scale = Math.min(scaleX, scaleY, 1);
                    }
                    
                    var canvas = document.createElement('canvas');
                    var ctx = canvas.getContext('2d');
                    
                    canvas.width = svgInfo.width * scale;
                    canvas.height = svgInfo.height * scale;
                    
                    var img = new Image();
                    
                    img.onload = function() {
                        // Clear canvas with white background
                        ctx.fillStyle = 'white';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Draw SVG
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        
                        resolve({
                            canvas: canvas,
                            width: canvas.width,
                            height: canvas.height,
                            originalWidth: svgInfo.width,
                            originalHeight: svgInfo.height,
                            scale: scale
                        });
                    };
                    
                    img.onerror = function() {
                        reject(new Error('Failed to render SVG'));
                    };
                    
                    // Create blob URL for the SVG
                    var svgBlob = new Blob([svgString], { type: 'image/svg+xml' });
                    var url = URL.createObjectURL(svgBlob);
                    
                    img.src = url;
                    
                    // Clean up the blob URL after a delay
                    setTimeout(function() {
                        URL.revokeObjectURL(url);
                    }, 1000);
                    
                } catch (error) {
                    reject(error);
                }
            });
        },
        
        // Optimize SVG content
        optimizeSVG: function(svgString) {
            try {
                // Basic SVG optimization - remove comments and unnecessary whitespace
                return svgString
                    .replace(/<!--[\s\S]*?-->/g, '') // Remove comments
                    .replace(/\s+/g, ' ') // Normalize whitespace
                    .replace(/>\s+</g, '><') // Remove whitespace between tags
                    .trim();
            } catch (error) {
                console.warn('SVG optimization failed:', error);
                return svgString;
            }
        },
        
        // Validate SVG content
        isValidSVG: function(svgString) {
            try {
                var parser = new DOMParser();
                var doc = parser.parseFromString(svgString, 'image/svg+xml');
                return doc.documentElement.nodeName !== 'parsererror';
            } catch (error) {
                return false;
            }
        },
        
        // Extract SVG metadata
        extractMetadata: function(svgString) {
            try {
                var svgInfo = SVGProcessor.parseSVG(svgString);
                var element = svgInfo.element;
                
                return {
                    width: svgInfo.width,
                    height: svgInfo.height,
                    viewBox: svgInfo.viewBox,
                    title: element.querySelector('title')?.textContent || '',
                    description: element.querySelector('desc')?.textContent || '',
                    creator: element.getAttribute('data-creator') || '',
                    elements: element.children.length,
                    hasAnimation: svgString.includes('animate') || svgString.includes('<animateTransform'),
                    size: new Blob([svgString]).size
                };
            } catch (error) {
                console.warn('Failed to extract SVG metadata:', error);
                return null;
            }
        }
    };
    
    // Export to global scope
    global.SVGProcessor = SVGProcessor;
    
    // For compatibility with svg.js library naming
    global.SVG = {
        processor: SVGProcessor,
        render: SVGProcessor.renderToCanvas,
        parse: SVGProcessor.parseSVG,
        optimize: SVGProcessor.optimizeSVG,
        isValid: SVGProcessor.isValidSVG
    };
    
    console.info('SVG processing utilities loaded');
    
})(typeof window !== 'undefined' ? window : global);